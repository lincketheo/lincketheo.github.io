<html>
  <head>
    <title>Notes on Goto/Jump</title>
    <link type="application/atom+xml" rel="alternate" href="/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Notes on Goto/Jump</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Notes on Goto/Jump" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Notes on Goto/Jump" />
<meta property="og:description" content="Notes on Goto/Jump" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-03T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Notes on Goto/Jump" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-03T00:00:00-04:00","datePublished":"2023-08-03T00:00:00-04:00","description":"Notes on Goto/Jump","headline":"Notes on Goto/Jump","mainEntityOfPage":{"@type":"WebPage","@id":"/computer%20science/2023/08/03/Flows.html"},"url":"/computer%20science/2023/08/03/Flows.html"}</script>
<!-- End Jekyll SEO tag -->

    <meta charset='UTF-8'>
<meta content='width=device-width, initial-scale=1' name='viewport'/>
<meta name='description' content='Theo Lincke is an electrical engineering masters student at George Masons University.'>
<meta name='keywords' content=''>
<meta name='author' content='Theo Lincke'>


    <link rel="stylesheet" href="/assets/css/styles.css">

    <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']]
    }
  };
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


  </head>
  <body>
    <div class='post wrap'>
    <nav id="blog_nav">
  
  <a href="/index.html" id="blog_nav_link">
    Home
  </a>
  
  <a href="/about.html" id="blog_nav_link">
    About
  </a>
  
  <a href="/feed.xml" id="blog_nav_link">
    RSS
  </a>
  
</nav>


    <div id='post_intro'>
        <div class='wrap'>
            <h1>Notes on Goto/Jump</h1>
            <h4>Woops, I crashed my program again</h4>
            <div class='bylines'>
                <div class='byline'>
                    <h3>Published</h3>
                    <p>03 August 2023</p>
                </div>
            </div>
            <div class='clear'></div>
        </div>
    </div>
    <div class='wrap article'>
        <h2 id="notes-on-gotojump">Notes on Goto/Jump</h2>

<p>This is a short one, but I don’t want to rush my fascination with structured concurrency and nonlinear program execution.
This post is inspired heavily by the following <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">source</a></p>

<p>Consider the regular python code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Hello World")
</code></pre></div></div>

<p>One key aspect of programming is abstraction over trust. As a programmer, I don’t need to know the implementation details of <code class="language-plaintext highlighter-rouge">print</code>. I don’t need to know that deep down,
python is just one big assembly program and it’s calling gross machine code all over the place, I just need to know that this single function will print the words “Hello World” to the console.
This is abstraction. This is one of Dennis Ritchie’s motivations for writing C. One thing you’ll notice early on when learning to write assembly code is the abundance of jumps; but what 
if in our programming language of choice (python), we relied heavily on jump statements and print was actually defined something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. # System print
2. def print(s):
3.  if s[0] == '\0':
4.    return
5.  else:
6.    system_print(s[0])
7.    s = s[1:]
8.    jump 3
</code></pre></div></div>

<p>Ugly right? (Of course, python strings aren’t null terminated, and that’s probably not how we jump in python. To be frank, I’m not sure what python’s version of goto is and I have 
never cared to check, even as I write this. I doubt there is one and by principle, I won’t check the internet because I don’t want to know :). It’s ugly, but it still makes sense. 
It’s pretty easy to break, though. How do we define where we jump in our language? I’m jumping to line 3 in the above example, but even languages as dumb as assembly include labels. So 
maybe our code could look something like this so that it’s not entirely broken when we add a new line or comment:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. # System print
2. def print(s):
3. label foo: 
4.  if s[0] == '\0':
5.    return
6. else:
7.    system_print(s[0])
8.    s = s[1:]
9.    jump foo
</code></pre></div></div>

<p>Great. But programmers make mistakes. Say we added a new feature. The author didn’t know that there was already a <code class="language-plaintext highlighter-rouge">foo</code> label defined, so they write a new foo label:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>label foo:
really_bad_piece_of_code

# System print
def print(s):
  label foo: 
  if s[0] == '\0':
    return
  else:
    system_print(s[0])
    s = s[1:]
    jump foo
</code></pre></div></div>

<p>Tough luck. There may be guards in our language, and we could keep spouting ways of fixing this problem (scope jumps to functions maybe? But what about within for loops. Isn’t an entire 
program just one big function?). The issue remains that, with jumps, <code class="language-plaintext highlighter-rouge">print</code> is unpredictable. There’s a certain contract that functions will finish after you call them. Otherwise, you
find yourself in gross hot messes.</p>

<p>Everyone who works in the code base needs to know that there’s a foo label in the <code class="language-plaintext highlighter-rouge">print</code> function before they write new stuff and they can’t abstract out control flows. We <em>could</em> trust the writer
of the <code class="language-plaintext highlighter-rouge">print</code> function and assume it acts the way we intend it to, but compile time errors are better than assumptions.</p>

<p>This, and more, is one of the reasons for Dijkstra highlights in <a href="https://www.cs.utexas.edu/~EWD/ewd02xx/EWD249.PDF">Notes On Structured Concurrency</a>. Jump statements
break programmer’s trust.</p>

<h2 id="a-final-note-on-cyclomatic-complexity">A Final Note on Cyclomatic Complexity</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if green:
    if red:
        for i in range(10):
          if blue:
              break
           else:
             if raining:
               print("Raining")
             else:
               print("Not raining")
          if turquoise:
            print("Turquise")
    switch animal:
      case sheep:
        print("No!")
      case possum:
        jump 2
      print("I'm a garbage program")
else:
  print("This isn't very fun to read")
</code></pre></div></div>

<p>Simple code is a pinnacle of software engineering, but most code, under the hood, jumps around a lot. A lot more than you’d think. The difference between an iterative assembly program that literally executes each line of code one after the other and a program as simple as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Hello world")
</code></pre></div></div>

<p>is astronomical. That one print statement contains so many jumps, and each one is abstracted out from the programmer. This is a good thing. Modern compilers optimize out useless jumps, but 
jumps and nonlinear programming execution flows shouldn’t be dismissed. They’re a crucial aspect of any programmer’s repertoire. It’s when we start doing things as ugly as the code I wrote a 
few paragraphs up that jumps and non linear programming execution flows cause problems. What in the world does that program do? I’m sure you could trace it out and simplify it a lot, but
the point is that abstraction is purely for us software engineers. Our computer doesn’t give a crap. It’s all the same code (just with more jumps under the hood). However, we’re writing code
to eliminate bugs and bugs show up when we don’t understand our code. My rant above ties pretty closely to the argument for minimizing Cyclomatic Complexity within our code so it’s easier to follow 
complex lines of logic. <strong>The less things we trust our software engineers to screw up, the better our programs become</strong>.</p>


    </div>

<script src="https://utteranc.es/client.js"
        repo="lincketheo/personal_website"
        issue-term="pathname"
        label="comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>

  </body>
</html>

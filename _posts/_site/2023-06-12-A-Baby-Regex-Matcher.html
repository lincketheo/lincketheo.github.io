<h2 id="introduction-a-simple-regex-matcher">Introduction: A Simple Regex Matcher</h2>

<p>In this post, I will define a regex and write a simple implementation in <code class="language-plaintext highlighter-rouge">C</code>.</p>

<p>The following is the description of our Regex:</p>

<hr />

<p>Let $\Sigma$ denote the english alphabet,</p>

<ul>
  <li>
    <p>A regex character $a$ can either be ‘.’, ‘*’ or $\in \Sigma$.</p>
  </li>
  <li>
    <p>A Kleene star (‘*’) indicates that the preceeding character (there’s garunteed to be a preceeding character before a Kleene star) can repeat 0 to many times.</p>
  </li>
  <li>
    <p>A ‘.’ can take the place of any character.</p>
  </li>
</ul>

<p>For example:</p>

<p>The following (input, regex) pairs match (where $\epsilon$ represents the empty string):</p>

\[aaa \quad a*\]

\[\epsilon \quad a*\]

<hr />

<h2 id="regular-expressions">Regular Expressions</h2>

<p>Each Regular Expression $r$ constructs a language $L(r)$ of all strings that satisfy $r$.</p>

<p>For example:</p>

\[L(a*) = \{\epsilon, a, aa, aaa, \dots\}\]

<p>A Regular Expression (RE) over some alphabet $\Sigma$ is defined via the following construction rules:</p>

<h3 id="base-rules">Base Rules:</h3>

<ul>
  <li>$\epsilon$ is a RE</li>
  <li>$\forall x \in \Sigma$, x is a RE</li>
</ul>

<h3 id="construction-rules">Construction Rules:</h3>

<ul>
  <li>$(r)|(s)$ is a RE, where</li>
</ul>

\[(r)|(s) = L(r) \cup L(s)\]

<ul>
  <li>$(r)(s)$ is a RE, where</li>
</ul>

\[(r)(s) = \{xy : \forall x,y \quad x \in L(r) \quad y \in L(s)\}\]

<ul>
  <li>$(r)*$ is a RE, where</li>
</ul>

\[(r)* = L(\epsilon) \cup L(r) \cup L(rr) \cup \dots\]

<p>Because we don’t have support for paranthetical expressions in our simple regex, I’m calling our regex a “simple” regex. I’m unsure if there is an official term for Regexes that don’t support grouping.</p>

<h2 id="writing-the-algorithm">Writing the Algorithm</h2>

<p>I’ll do this recursively. I want my “algorithm explained” series to really dive into the thought process of how to solve the problem, but remember that it’s obviously much <em>easier</em> to reason through as someone who’s solved the problem already. This is <em>obviously</em> not how simple my thought process was, rather a set of concrete “aha’s” I went through and their subsequent effect on my code.</p>

<blockquote>
  <p>Side Note: For me writing this blog post, I reasoned through how I could make my code much better / readable. It’s an interesting observation that my first (successful) attempt looked like this:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool matches_r(const char *input, const char *regex) {
  // Invalid cases
  if (*regex == '*') {
    printf("Invalid Regex\n");
    return false;
  }

  if (*regex == '\0') {
    return *input == '\0';
  }

  if (*regex != '\0' &amp;&amp; *(regex + 1) != '*') {
    if (*regex == '.') {
      if (*input == '\0') {
        return false;
      }
      return matches_r(input + 1, regex + 1);
    } else {
      if (*input != *regex) {
        return false;
      }
      return matches_r(input + 1, regex + 1);
    }
  }

  if (*regex != '\0' &amp;&amp; *(regex + 1) == '*') {
    bool valid_first = (*input != '\0') &amp;&amp; (*input == *regex || *regex == '.');
    return matches_r(input, regex + 2) || (valid_first &amp;&amp; matches_r(input + 1, regex));
  }

  printf("Can't reach this spot");
  return false;
}
</code></pre></div></div>

<blockquote>
  <p>You’ll see my subsequent attempt at the end, and the obvious reduction in gross logic is a direct consequence of writing this blog post and re doing my work. All that to say, re writing code and writing about your code does wonders!</p>
</blockquote>

<p>Our outline will look something like this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nf">matches</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">regex</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// todo</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that no matter where you are in the string, you need at least two characters to know what to match. That is, ‘aa’ and ‘a*’ mean two very different things. Therefore, we can eliminate the idea of a context free DSA in our regex.</p>

<p>In order to find all of our recursive conditions, observe that (where ‘a’ represents any character in $\Sigma$):</p>

<ol>
  <li>The first regex character could be a null terminator (‘\0’)</li>
  <li>The first regex character could be ‘.’ and the next character could not be ‘*’
    <ul>
      <li>E.g. “.a” or “.”</li>
    </ul>
  </li>
  <li>The first regex character could be ‘a’ and the next character could not be ‘*’
    <ul>
      <li>E.g. “aa” or “a”</li>
    </ul>
  </li>
  <li>The first regex character could be ‘.’ and the next character could be ‘*’
    <ul>
      <li>E.g. “.*”</li>
    </ul>
  </li>
  <li>The first regex character could be ‘a’ and the next character could be ‘*’
    <ul>
      <li>E.g. “a*”</li>
    </ul>
  </li>
</ol>

<p>And the logic for each case (quotes around “Check” to denote ambiguity):</p>

<ol>
  <li>Check if the input string is also empty - if it is, we’ve matched our string</li>
  <li>“Check” the first character, then run <code class="language-plaintext highlighter-rouge">matches(input + 1, regex + 1)</code></li>
  <li>Similar to (2)</li>
  <li>If the first character doesn’t match, then we can simply check <code class="language-plaintext highlighter-rouge">matches(input, regex + 2)</code> because the kleene star can match 0 characters. Otherwise, if the character matches, then we can run <code class="language-plaintext highlighter-rouge">matches(input + 1, regex)</code>. Also note that if we execute (1-3) correctly, we can ensure we’re not overflowing our buffer.</li>
  <li>Similar to (4)</li>
</ol>

<p>At a high level, here’s our solution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool matches_r(const char *input, const char *regex) {
  if (*regex == '\0')
    return *input == '\0';

  bool match = (*regex == *input || *regex == '.');

  if (*(regex + 1) != '*')
    return match &amp;&amp; matches_r(input + 1, regex + 1);

  return matches_r(input, regex + 2) || (match &amp;&amp; matches_r(input + 1, regex));
}
</code></pre></div></div>

<p>But we slightly glossed over case (1). What if input is ‘\0’ and regex matches case 2, we’ll overflow our buffer (mentioned in (4)). _All we need to do is avoid adding anything to <code class="language-plaintext highlighter-rouge">input</code> if <code class="language-plaintext highlighter-rouge">input = '\0'</code>. It looks like <code class="language-plaintext highlighter-rouge">match</code> acts as a short circuit for each case this could happen, so let’s just add the condition there:</p>

<h3 id="the-final-code">The Final Code:</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool matches_r(const char *input, const char *regex) {
  if (*regex == '\0')
    return *input == '\0';

  bool first_matches = (*input != '\0') &amp;&amp; (*regex == *input || *regex == '.');

  if (*(regex + 1) != '*') 
    return first_matches &amp;&amp; matches_r(input + 1, regex + 1);

  return matches_r(input, regex + 2) || (first_matches &amp;&amp; matches_r(input + 1, regex));
}
</code></pre></div></div>

<h2 id="memoizing">Memoizing</h2>

<p>Classically, in dynamic programming, you’d recognize that you’re executing duplicate code, so you “memoize” that code for later. That is, our problem has <strong>optimal substructure</strong>. I’ll do this problem again in the future while accounting for this property.</p>

